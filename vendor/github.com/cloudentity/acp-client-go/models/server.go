// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Server Multi Tenant authorization server
//
// swagger:model Server
type Server struct {

	// Access token strategy
	AccessTokenStrategy string `json:"access_token_strategy,omitempty"`

	// Access token time to live (default 1 hour)
	// Format: duration
	AccessTokenTTL strfmt.Duration `json:"access_token_ttl,omitempty"`

	// Authorization code time to live (default 10 minutes)
	// Format: duration
	AuthorizationCodeTTL strfmt.Duration `json:"authorization_code_ttl,omitempty"`

	// Client certificate header name containing certificate in pem format
	ClientCertificateHeader string `json:"client_certificate_header,omitempty"`

	// Color
	Color string `json:"color,omitempty"`

	// Cookie max age (default 1 hour)
	// Format: duration
	CookieMaxAge strfmt.Duration `json:"cookie_max_age,omitempty"`

	// Enforce pkce (default false)
	EnforcePKCE bool `json:"enforce_pkce,omitempty"`

	// Enforce pkce for public clients (default false)
	EnforcePKCEForPublicClients bool `json:"enforce_pkce_for_public_clients,omitempty"`

	// Supported grant types
	GrantTypes []string `json:"grant_types"`

	// Unique identifier. If not provided will be generated
	ID string `json:"id,omitempty"`

	// ID token time to live (default 1 hour)
	// Format: duration
	IDTokenTTL strfmt.Duration `json:"id_token_ttl,omitempty"`

	// Authorization Server Issuer. If not provided will be set based on deployment configuration
	IssuerURL string `json:"issuer_url,omitempty"`

	// Key type used to generate key which will be used to sign access and id tokens
	// Used only as input parameter in Create Authorization Server API
	// Currently `rsa` and `ecdsa` are supported
	KeyType string `json:"key_type,omitempty"`

	// Logo URI
	LogoURI string `json:"logo_uri,omitempty"`

	// Name
	Name string `json:"name,omitempty"`

	// Server profile
	Profile string `json:"profile,omitempty"`

	// Flag indicating whether client certificate should be read from header.
	// If set to true, than the client certificate header is required.
	// This is useful for behind load balancer setup.
	ReadClientCertificateFromHeader bool `json:"read_client_certificate_from_header,omitempty"`

	// Refresh token time to live (default 30 days - 720 hours)
	// Format: duration
	RefreshTokenTTL strfmt.Duration `json:"refresh_token_ttl,omitempty"`

	// PEM encoded root CA certificates used for client mtls token endpoint authentication.
	// If not set the system root CA certifiates are used instead.
	RootCAs string `json:"root_cas,omitempty"`

	// Rotated secrets used for validating old tokens
	RotatedSecrets []string `json:"rotated_secrets"`

	// Secret used for hashing, must have at least 32 characters. If not provided will be generated.
	Secret string `json:"secret,omitempty"`

	// Salt used to hash subject when pairwise subject type is used
	SubjectIdentifierAlgorithmSalt string `json:"subject_identifier_algorithm_salt,omitempty"`

	// Supported subject identifier types
	SubjectIdentifierTypes []string `json:"subject_identifier_types"`

	// tenant ID
	TenantID string `json:"tenant_id,omitempty"`

	// Supported token endpoint authentication methods
	TokenEndpointAuthnMethods []string `json:"token_endpoint_authn_methods"`

	// Server type
	Type string `json:"type,omitempty"`

	// dynamic client registration
	DynamicClientRegistration *DynamicClientRegistrationSettings `json:"dynamic_client_registration,omitempty"`

	// jwks
	Jwks *JWKs `json:"jwks,omitempty"`
}

// Validate validates this server
func (m *Server) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessTokenTTL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthorizationCodeTTL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCookieMaxAge(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIDTokenTTL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRefreshTokenTTL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDynamicClientRegistration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJwks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Server) validateAccessTokenTTL(formats strfmt.Registry) error {

	if swag.IsZero(m.AccessTokenTTL) { // not required
		return nil
	}

	if err := validate.FormatOf("access_token_ttl", "body", "duration", m.AccessTokenTTL.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Server) validateAuthorizationCodeTTL(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthorizationCodeTTL) { // not required
		return nil
	}

	if err := validate.FormatOf("authorization_code_ttl", "body", "duration", m.AuthorizationCodeTTL.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Server) validateCookieMaxAge(formats strfmt.Registry) error {

	if swag.IsZero(m.CookieMaxAge) { // not required
		return nil
	}

	if err := validate.FormatOf("cookie_max_age", "body", "duration", m.CookieMaxAge.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Server) validateIDTokenTTL(formats strfmt.Registry) error {

	if swag.IsZero(m.IDTokenTTL) { // not required
		return nil
	}

	if err := validate.FormatOf("id_token_ttl", "body", "duration", m.IDTokenTTL.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Server) validateRefreshTokenTTL(formats strfmt.Registry) error {

	if swag.IsZero(m.RefreshTokenTTL) { // not required
		return nil
	}

	if err := validate.FormatOf("refresh_token_ttl", "body", "duration", m.RefreshTokenTTL.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Server) validateDynamicClientRegistration(formats strfmt.Registry) error {

	if swag.IsZero(m.DynamicClientRegistration) { // not required
		return nil
	}

	if m.DynamicClientRegistration != nil {
		if err := m.DynamicClientRegistration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dynamic_client_registration")
			}
			return err
		}
	}

	return nil
}

func (m *Server) validateJwks(formats strfmt.Registry) error {

	if swag.IsZero(m.Jwks) { // not required
		return nil
	}

	if m.Jwks != nil {
		if err := m.Jwks.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jwks")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Server) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Server) UnmarshalBinary(b []byte) error {
	var res Server
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
